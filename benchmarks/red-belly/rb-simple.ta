/* a threshold automata for the binary value broadcast in the paper: Holistic verification of Blockchain protocol */

skel Proc {

  local pc;
  shared bvb0, bvb1, a0, a1, dbvb0, dbvb1, da0, da1, a0pa1, da0pa1;
  parameters N, T, F;


  assumptions (0) {
    N > 3 * T;
    T >= F;
    F >= 0;
  }

  locations (0) {
    locV0: [0];
    locV1: [1];
    locM: [2];
    locM0: [3];
    locM1: [4];
    locM01: [5];
    locE0: [6];
    locE1: [7];
    locD0: [8];
    locD1: [9];
    locV0d: [10];
    locV1d: [11];
    locMd: [12];
    locM0d: [13];
    locM1d: [14];
    locM01d: [15];
    locE0d: [16];
    locE1d: [17];
    locD0d: [18];
  }

  inits (0) {
    (locV0 + locV1) == N - F;
    locM == 0;
    locM0 == 0;
    locM1 == 0;
    locM01 == 0;
    locE0 == 0;
    locE1 == 0;
    locD1 == 0;
    locD0 == 0;
    locV0d == 0;
    locV1d == 0;
    locMd == 0;
    locM0d == 0;
    locM1d == 0;
    locM01d == 0;
    locE0d == 0;
    locE1d == 0;
    locD0d == 0;
    bvb0 == 0;
    bvb1 == 0;
    a0 == 0;
    a1 == 0;
    dbvb0 == 0;
    dbvb1 == 0;
    da0 == 0;
    da1 == 0;
    a0pa1 == 0;
    da0pa1 == 0;
  }

  rules (19) {  
 
  0: locV0 -> locM
      when (true)
      do {bvb0' == bvb0 + 1; };
  1: locV1 -> locM
      when (true)
      do {bvb1' == bvb1 + 1; };
  2: locM -> locM
      when (true)
      do{};
  3: locM -> locM0
      when (bvb0 >= 1)
      do{a0' == a0 + 1; a0pa1' == a0pa1 + 1; };
  4: locM -> locM1
      when (bvb1 >= 1)
      do{a1' == a1 + 1; a0pa1' == a0pa1 + 1;};      
  5: locM0 -> locM0
      when (true)	
      do{};                 
  6: locM0 -> locE0
      when (a0 >= N - T - F)
      do{}; 
  7: locM0 -> locM01
      when (bvb1 >= 1)
      do{};  
  8: locM1 -> locM1
      when (true)	
      do{};                 
  9: locM1 -> locD1
      when (a1 >= N - T - F)
      do{}; 
  10: locM1 -> locM01
      when (bvb0 >= 1)
      do{};
  11: locM01 -> locM01
      when (true)
      do{};
  12: locM01 -> locE0
      when (a0 >= N - T - F)
      do{};
  13: locM01 -> locE1
      when (a0pa1 >= N - T - F)
      do{};
  14: locM01 -> locD1
      when (a1 >= N - T - F)
      do{};
  15: locE0 -> locV0d
      when (true)
      do{};
  16: locE1 -> locV1d
      when (true)
      do{};
  17: locD1 -> locV1d
      when (true)
      do{};     
      
  18: locV0d -> locMd
      when (true)
      do {dbvb0' == dbvb0 + 1; };
  19: locV1d -> locMd
      when (true)
      do {dbvb1' == dbvb1 + 1; };
  20: locMd -> locMd
      when (true)
      do{};
  21: locMd -> locM0d
      when (dbvb0 >= 1)
      do{da0' == da0 + 1; da0pa1' == da0pa1 + 1; };
  22: locMd -> locM1d
      when (dbvb1 >= 1)
      do{da1' == da1 + 1; da0pa1' == da0pa1 + 1;};      
  23: locM0d -> locM0d
      when (true)	
      do{};                 
  24: locM0d -> locD0
      when (da0 >= N - T - F)
      do{}; 
  25: locM0d -> locM01d
      when (dbvb1 >= 1)
      do{};  
  26: locM1d -> locM1d
      when (true)	
      do{};                 
  27: locM1d -> locE1d
      when (da1 >= N - T - F)
      do{}; 
  28: locM1d -> locM01d
      when (dbvb0 >= 1)
      do{};
  29: locM01d -> locM01d
      when (true)
      do{};
  30: locM01d -> locD0
      when (da0 >= N - T - F)
      do{};
  31: locM01d -> locE0d
      when (da0pa1 >= N - T - F)
      do{};
  32: locM01d -> locE1d
      when (da1 >= N - T - F)
      do{};
  }
  

  specifications (0) {

    validity0: (locV0 == 0) -> [](locD0 == 0);

    validity1: (locV1 == 0) -> [](locD1 == 0);
  }
} /* Proc */ 


