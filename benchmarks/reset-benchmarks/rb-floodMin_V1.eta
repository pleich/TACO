/* FloodMin check paper : "Tight bounds for k-set agreement"  and paper: "Verifying Safety of Synchronous Fault-Tolerant Algorithms by Bounded Model Checking" */

skel Proc {

  local pc;
  shared x0, x1, total, count, round;
  parameters N, T, F, L;


  assumptions (0) {
    N > 3 * T;
    T >= F;
    F >= 0;
    L >= N - F;
  }

  locations (0) {
    locV0: [0];
    locV1: [1];
    locW: [2];
    locTD0: [3];
    locTD1: [4];
    locD0: [5];
    locD1: [6];
  }

  inits (0) {
    locV0 == N - F;
    locV1 == 0;
    locW == 0;
    locTD0 == 0;
    locTD1 == 0;
    locD0 == 0;
    locD1 == 0;
    x0 == 0;
    x1 == 0;
    total == 0;
    count == 0;
    round == 0;
  }

  rules (19) {
  
  0: locV0 -> locW
      when (true)
      do{x0' == x0 + 1; total' == total + 1;};
  1: locV1 -> locW
      when (true)
       do{x1' == x1 + 1; total' == total + 1;};
  2: locW -> locTD0
      when (x0 >= 1)
      do{count' == count + 1;};
  3: locW -> locTD1
      when (total >= L && x0 < 1)
      do {count' == count + 1;};
  4: locTD0 -> locV0
      when (count >= N-F && round < T + 1)
      do {round' == round + 1; x0' ==0; x1' ==0; total'==0; count' ==0;};
  5: locTD0 -> locV0
      when (count < 1)
      do {};
  6: locTD0 -> locD0
      when (round >= T + 1)
      do {};
  7: locTD1 -> locV1
      when (count >= N-F && round < T + 1)
      do {round' == round + 1; x0' ==0; x1' ==0; total'==0; count' ==0;};
  8: locTD1 -> locV1
      when (count < 1)
      do {};
  9: locTD1 -> locD1
      when (round >= T + 1)
      do {};
  
  }

  specifications (0) {    
    validity1: (locV1 == 0) -> [](locD1 == 0);
  }
} /* Proc */ 
