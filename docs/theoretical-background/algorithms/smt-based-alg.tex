\subsection{SMT Model Checking Algorithm}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{./resources/smt-algorithm.webp}
    \caption{Architecture of the SMT-based model checking algorithm.}\label{fig:alg-smt}
\end{figure}

Balasubramanian et al.~\citep{Balasubramanian20} showed that the reachability problem for MTA can be reduced to deciding the satisfiability of an SMT formula.
More precisely, they construct an existential Presburger arithmetic formula $\phi_{REACH}(\sigma,\sigma')$ such that $\phi_{REACH}(\sigma,\sigma')$ holds if and only if $\sigma'$ is reachable from $\sigma$ for the given MTA.

A central notion in this construction is the \emph{context} of a configuration $\sigma$, defined as the set of lower guards that evaluate to true together with the upper guards that evaluate to false.
A MTA path is called \emph{steady} if all its configurations have the same context.
The key idea underlying the SMT-based approach is that any MTA execution with $k$ guards can be represented as the concatenation of at most $k+1$ steady paths~\citep{Balasubramanian20}.
Therefore, for each steady path, the formula $\phi_{REACH}(\sigma,\sigma')$ encodes several constraints: the number of times each rule is fired, the effect on the number of processes in each location, the changes to shared variables, and that each fired rule is reachable via a sequence of rules where the target location of one rule provides the source location required to fire the next, starting from a location that initially contains a process~( ``firable'' chain of rules).
Additional base constraints ensure that parameters, total process counts, and the guard context remain consistent along the path. 
Formally, the construction yields:\\
$\boldsymbol{\phi_{\text{\textbf{REACH}}}(\sigma, \sigma')} \equiv \exists \sigma_0, \sigma_0', \ldots, \sigma_{\boldsymbol{K}}, \sigma_{\boldsymbol{K}}'$\\
$\phantom{aaaaa} \left( 
\sigma_0 = \sigma \wedge \sigma_{\boldsymbol{K}}' = \sigma' \wedge 
\bigwedge_{0 \leq i \leq \boldsymbol{K}} \boldsymbol{\phi_{\text{steady}}}(\sigma_i, \sigma_i') \wedge 
\bigwedge_{0 \leq i \leq \boldsymbol{K}-1} \boldsymbol{\phi_{\text{step}}}(\sigma_i', \sigma_{i+1})
\right)$

where $\phi_{\text{step}}(\sigma, \sigma')$ is a polynomial sized existential Presburger formula such that $\phi_{\text{step}}(\sigma, \sigma')$ is true iff $\sigma'$ can be reached from $\sigma$ by firing at most one rule.

Note that the above construction may produce formulas of exponential size due to the exponential number of possible rule chains (see~\citep{Balasubramanian20} for details).

\textbf{Implementation Details.}
This algorithm uses the basic TA representation, shown as LIATA in \cref{fig:architecture}.

In contrast to the original implementation of the approach~\citep{Balasubramanian20}, we do not use non-deterministic guessing to keep SMT queries small.
Instead, we encode all steady paths and leave it to the SMT solver to resolve the non-determinism.

\textbf{Usage.} To use the SMT model checking algorithm with TACO, the user needs to specify the option \texttt{smt} when invoking the tool from the command line.